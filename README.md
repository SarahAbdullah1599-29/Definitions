DevOps-Concept

							Software Delivery Cycle
Source: https://stackify.com/what-is-sdlc/

This is the process of creating high-quality software, otherwise best known as Software Development Life Cycle (SDLC). It focuses on the phases of Software Development that slows a software to be delivered. The main goal in producing a software is to have a product of the highest quality and lowest production cost. Hence, having a production cycle makes organizing such product easier.

Planning / Requirement Analysis: Reviewing the cost and resources and detailing the risk involved and risk management steps, to avoid these situations hence being able to start a project with the lowest risk in mind.

Design: This is where we ask the question “How will we get what we want?” Here we turn the software specification into a design plan called the design specification. In this stage it is crucial for feedbacks, offers and suggestions, and allowing all stakeholders and partners a fair chance to share their views.

Build: the development officially begins at this stage and it is important that every developer stick to the blueprint that was created in the design step. This will produce a smooth testing step.

Code Test: Here we begin to test for defects and deficiencies and once this is sorted we being to fix those issues to meet the software original specification.

Software Deployment: Here we begin to use what we produced. We deploy it to the production environment, so users are given a chance to use the product.

An extra step we can take in the software delivery cycle is software maintenance, constant maintenance of our software allows us to import and keep making changes to fit our users needs and wants, hence keeping them interested and active in our production.

				                            Test Driven Development
Source: https://www.guru99.com/test-driven-development.html

This approach is to ensure that the source code is thoroughly tested at confirmatory level. It ensures that the system meets the requirement defined for it and its focus is more on the production code that verifies whether testing will work properly. In TDD you achieve full coverage testing that is every line of code is tested.
Test Driven Development Cycle is done as followed: 
1)	Write a test
2)	Make it run
3)	Change the code to make it right i.e. Refactor
4)	Repeat process

                                                                Continuous Integration
Source: https://aws.amazon.com/devops/continuous-integration/

This is a DevOps software development practice where developers regularly merge their code changes into a central repository after which automated builds and tests are run. This is best known as the build or integration stage of the software release process and entails both an automation component and a cultural component. The entire purpose of this process it to address bugs in the software faster and improve software quality and reduce the time it takes to validate and release new software updates.

					                        Continuous Delivery
Source: https://aws.amazon.com/devops/continuous-delivery/

This is a software development practice where code changes are automatically prepared for a release to production. This allows developer automate testing beyond just unit tests so they can verify application updates across multiple dimension before deploying to customers. Some of these tests may include UI testing, loading testing, integration testing, API reliability testing etc. This allows developers a more thorough chance to validate updates and glitches in their software.

					                        Configuration Management
Source: https://www.bmc.com/blogs/devops-configuration-management/#:~:text=Configuration%20management%20occurs%20when%20a,applications%2C%20and%20other%20managed%20systems.

This occurs when a configuration platform is used to automate, monitor, design and manage otherwise manual configuration processes. System-wide changes takes place across server and networks, storage, application and other managed systems.
The components of configuration management are:
1)	Identification: The process of finding and cataloging system-wide configuration needs.
2)	Control: Due to the intensity of changes taking place we use control configuration that allows changes to take place over time without destabilizing integration and existing infrastructure. 
3)	Audit: This is done in order to ensure that the existing system stands up to the compliance regulations and validations.

                                                               Containerization
Source: https://www.linuxnix.com/what-is-containerization-in-devops/
 https://www.ibm.com/cloud/learn/containerization
 
It is an alternative to a virtual machine that involves encapsulating an application in a container with its own operating system. In other words, it is the process of encapsulating or packaging up software codes and all its dependencies so that it can run uniformly and consistently on any infrastructure. This becomes an advantage since technology is improving at a rapid rate, we want software to be working on all platform infrastructure.

					                     Cloud Stability and Reliability
Source: https://www.mtm.com/cloud-stability-in-2019-three-easy-steps/
https://link.springer.com/article/10.1186/s13673-018-0143-8#:~:text=Reliability%20shows%20the%20probability%20of,fail%20during%20its%20operating%20time.

Cloud Stability is the process of ensuring that as cloud adoption grows and continues to expand , that there is a consistency in your cloud ecosystem, whether it is private, public or hybrid cloud. 
Cloud Reliability: This shows the probability of a system/component for performing the required function in a period of time without failure. 

							Software Architecture
Source: https://martinfowler.com/architecture/
https://www.tutorialspoint.com/software_architecture_design/introduction.htm
Software Archietecture referse to the notion of having a strong system designed internally, by providing this foundation it gives a much efficient software at a cheaper rate.This describes the major components, their relationships and how they interact with each other. These may include the business strategy, quality attributes , human dynamics , design and IT environment.Its main purpose serves as the blueprint for a system that desfines a structured solution to meet all the technical and operational requirement while optimizing the common attributes such as performance and security.

							Software
Source:https://searchapparchitecture.techtarget.com/definition/software
Software is a set of instructions, data or programs used to operate computers and execute specific task , they are application software otherwise known as user-downloaded prorgams that fulfills a users needs and wants and system software that supports the application software.

							Client/Server
Source:https://www.tutorialspoint.com/Client-Server-Computing
Client and Server is a computing relationship where the clients request resources and the server points to the resoruces. A server may serve multiple clients at the same time but a client can only work with one server. This communication is usually done over a computer network.

						Peer-to-Peer
Source:https://www.computerworld.com/article/2588287/networking-peer-to-peer-network.html
This is the process where two or more PCs are connected and share resoruces without going through a separate server computer. This can be set up in a permanent infrustructure that links dozen of computer via copper wire or over a network over the internet.

						Monolithic
Source:https://www.sciencedirect.com/topics/computer-science/monolithic-application
https://whatis.techtarget.com/definition/monolithic
Monolithic is where an application is built as a single unit. It is a traditional programming model, this means that each program is independed and then they are interwoven with each other.

						Microservice
Source:https://www.ibm.com/cloud/learn/microservices#:~:text=Microservices%20(or%20microservices%20architecture)%20are,These%20services%20typically
Microservice are an architectual and organizational appraoch to software where a software is composed of small independent services that communicate over well defined APIs. With Microservices an application is built as independent components that run each application process as a service.

